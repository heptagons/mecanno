package nest

import (
	"testing"
)

// Test without simplifications done with a factory
func TestA32_(t *testing.T) {

	q := newA32(0, 0)
	// sbcd
	for _, r := range []struct { x, y, z Z; exp string } {
		{ 0, 0, 0, "0"       },
		{ 0, 0, 1, "0"       },
		{ 0, 1, 1, "1"       },
		{ 0, 1, 4, "√4"      },
		{ 0, 2, 4, "2√4"     },
		{ 1, 2, 4, "1+2√4"   },
		{ 2, 2,-4, "2+2i√4"  },
		{ 3,-2,-4, "3-2i√4"  },
		{-4,-2,-4, "-4-2i√4" },
		{-5,-2,-1, "-5-2i"   },
		{-5,-1,-1, "-5-i"    },
		{-6,-2, 0, "-6"      },
		{-7, 0, 0, "-7"      },
		{-8, 2, 1, "-8+2"    },
	} {
		s := &Str{}
		q.sbcd(s, r.x, r.y, r.z)
		if got := s.String(); got != r.exp {
			t.Fatalf("sbcd got %s exp %s", got, r.exp)
		}
	}

	for _, s := range []struct { q *A32; exp string } {
		{ newA32(0),             "NaN"     },
		{ newA32(1),             "Invalid" },
		{ newA32(1,2,3),         "Invalid" },
		{ newA32(1,2,3,4,5),     "Invalid" },
		{ newA32(1,2,3,4,5,6,7), "Invalid" },

		{ newA32(0,1), "NaN" },
		{ newA32(7,0), "0"   },
		{ newA32(7,7), "7/7" },
		{ newA32(7,1), "1/7" },
		{ newA32(1,7), "7"   },

		{ newA32(1,2,3,4), "2+3√4"     },
		{ newA32(2,3,4,5), "(3+4√5)/2" },
		{ newA32(2,0,1,1), "1/2"       },
		{ newA32(1,0,1,1), "1"         },
		{ newA32(1,0,0,0), "0"         },
		{ newA32(1,2,3,0), "2"         },

		// len(num)=5
		{ newA32(1,2,3,4,5,6), "2+3√4+5√6"     },

		{ newA32(2,3,4,5,6,7), "(3+4√5+6√7)/2" },

		{ newA32(2,0,4,5,6,7), "(4√5+6√7)/2"   }, // b=0
		{ newA32(2,3,4,0,6,7), "(3+6√7)/2"     }, // d=0
		{ newA32(2,3,0,5,6,7), "(3+6√7)/2"     }, // c=0

		{ newA32(2,3,4,5,0,7), "(3+4√5)/2"     }, // e=0
		{ newA32(2,3,4,5,6,0), "(3+4√5)/2"     }, // f=0

		{ newA32(2,0,4,0,6,7), "6√7/2"         }, // b=d=0
		{ newA32(2,0,4,5,0,7), "4√5/2"         }, // b=e=0
		{ newA32(2,3,0,5,0,7), "3/2"           }, // c=e=0
		{ newA32(2,0,0,5,0,7), "0"             }, // b=c=e=0

		{ newA32(2,3,4,+1,6,7), "(3+4+6√7)/2"   }, // d=+1
		{ newA32(2,3,4,-1,6,7), "(3+4i+6√7)/2"  }, // d=-1
		{ newA32(2,0,4,5,6,+1), "(4√5+6)/2"     }, // f=+1
		{ newA32(2,0,4,5,6,-1), "(4√5+6i)/2"    }, // f=-1

		{ newA32(2, 2, 2, 2, 2, 2), "(2+2√2+2√2)/2" },
		{ newA32(1,-1,-1,-1,-1,-1), "-1-i-i" },
		{ newA32(1,-1,-1,+1,-1,+1), "-1-1-1" },

		// len(num)=7
		{ newA32(2,3,4,5,6,7,8,9), "(3+4√5+6√(7+8√9))/2" },
		
		{ newA32(2,3,4,5,+1,7,8,9), "(3+4√5+√(7+8√9))/2" }, // e=+1
		{ newA32(2,3,4,5,-1,7,8,9), "(3+4√5-√(7+8√9))/2" }, // e=-1

		{ newA32(2,3,4,5,6,7,8,0), "(3+4√5+6√(7))/2" }, // h=0
		{ newA32(2,3,4,5,6,7,0,9), "(3+4√5+6√(7))/2" }, // g=0

		{ newA32(2,3,4,5,6,7,8,1), "(3+4√5+6√(7+8))/2"  }, // h=1
		{ newA32(2,3,4,5,6,7,1,9), "(3+4√5+6√(7+√9))/2" }, // g=1
		{ newA32(2,3,4,5,6,0,8,9), "(3+4√5+6√(8√9))/2"  }, // f=0

		{ newA32(2,3,4,5,6,0,0,9), "(3+4√5)/2"  }, // f=g=0
		{ newA32(2,3,4,5,6,0,8,0), "(3+4√5)/2"  }, // f=h=0

	} {
		if got := s.q.String(); got != s.exp {
			t.Fatalf("newA32 got %s exp %s", got, s.exp)
		}
	}
}

// TestA32s tests simplifications done with a factory
// for operations like aNew, aAdd, 

func TestA32s(t *testing.T) {

	f := func(p ...Z) []Z { return p }

	qs := NewA32s()

	m := make(map[string]*A32, 0)

	// aNew
	for _, s := range []struct { nums []Z ; den N; exp string; } {
		{ f(),  1, "err" },
		{ f(0), 0, "err" },
		{ f(0), 1, "0"   },
		{ f(4), 2, "2"   },
		{ f(1), 2, "1/2" },
		{ f(1), 4, "1/4" },

		{ f( 1,2),   2, "err"  },

		// (b + c√d)/a		
		{ f( 0,1,1), 1, "1"    }, // (0+1√1)/1 = (1)/1 = 1
		{ f( 1,1,1), 1, "2"    }, // (1+1√1)/1 = (1+1)/1 = 2
		{ f( 0,1,2), 1, "√2"   }, // (0+1√2)/1 = (√2)/1 = √2
		{ f( 1,1,2), 1, "1+√2" }, // 1+1√2
		{ f( 1,1,3), 1, "1+√3" }, // 1+1√3
		{ f( 1,1,4), 1, "3"    }, // 1+1√4 = 1+2 = 3
		{ f( 1,1,5), 1, "1+√5" }, // 1+1√5
		
		{ f( 1,1,5), 2, "(1+√5)/2" }, // (1+1√5)/2
		{ f( 1,1,6), 2, "(1+√6)/2" }, // (1+1√5)/2
		{ f( 2,1,7), 2, "(2+√7)/2" }, // (1+1√5)/2
		{ f( 2,1,8), 2, "1+√2"     }, // (2+2√2)/2 = 1+√2
		{ f( 2,1,9), 2, "5/2"      }, // (2+1√9)/2 = (2+3)/2 = 5/2
		{ f(-2,1,9), 2, "1/2"      }, // (-2+1√9)/2 = (-2+3)/2 = 1/2

		{ f( 0,2,1), 2,  "1"       }, // (2√1)/2 = 1
		{ f( 0,2,2), 2,  "√2"      }, // (2√2)/2 = √2
		{ f( 0,4,5), 6,  "2√5/3"   }, // (0+4√5)/6 = 4√5/6 = 2√5/3

		{ f(0,147,11),2500, "147√11/2500" },
		{ f(0, 6,33),  99,  "2√33/33"     },

		// (b + c√d e√f)/a

		{ f(1,1,1,1,1), 0, "err"  },

		{ f(0,1,2,3,4), 5, "(6+√2)/5"  }, // (1√2+3√4)/5 = (1√2+6)/5 = (6+√2)/5
		{ f(1,0,2,3,4), 5, "7/5"       }, // (1+0√2+3√4)/5 = (1+3√4)/5 = (1+6)/5 = 7/5
		{ f(1,2,0,3,4), 5, "7/5"       }, // (1+2√0+3√4)/5 = (1+3√4)/5 = (1+6)/5 = 7/5
		{ f(1,2,3,0,4), 5, "(1+2√3)/5" }, // (1+2√3+0√4)/5 = (1+2√3)/5
		{ f(1,2,3,4,0), 5, "(1+2√3)/5" }, // (1+2√3+0√4)/5 = (1+2√3)/5

		{ f(1,2,3,4,5), 6, "(1+2√3+4√5)/6" }, // (1+2√3+4√5)/6 
		{ f(1,2,3,0,5), 6, "(1+2√3)/6"     }, // (1+2√3+0√5)/6 = (1+2√3)/6  f==0
		{ f(1,2,3,4,0), 6, "(1+2√3)/6"     }, // (1+2√3+4√0)/6 = (1+2√3)/6  f==0
		{ f(1,2,3,4,1), 6, "(5+2√3)/6"     }, // (1+2√3+4)/6 = (5+2√3)/6    f==1
		{ f(1,2,3,4,3), 6, "(1+6√3)/6"     }, // (1+2√3+4√3)/6 = (1+6√3)/6  d==f==3
		{ f(1,2,1,4,3), 6, "(3+4√3)/6"     }, // (1+2√1+4√3)/6 = (3+4√3)/6  c=1

		{ f(1,1,1,1,1), 1, "3"     }, // (1+1√1+1√1)/1 = (1+1+1)/1 = 3
		{ f(2,2,2,2,2), 2, "1+2√2" }, // (2+2√2+2√2)/2 = (2+4√2)/2 = 1+2√2
		{ f(3,3,3,3,3), 3, "1+2√3" }, // (3+3√3+3√3)/3 = (3+6√3)/3 = 1+2√2
		{ f(4,4,4,4,4), 4, "5"     }, // (4+4√4+4√4)/4 = (4+8+8)/4 = 5
		{ f(5,5,5,5,5), 5, "1+2√5" },
		
		{ f(2,3,4,5,6), 7, "(8+5√6)/7"      }, // (2+3√4+5√6)/7 = (2+6+5√6)/7 = (8+5√6)/7
		{ f(3,4,5,6,7), 8, "(3+4√5+6√7)/8"  }, // (3+4√5+6√7)/8
		{ f(4,5,6,7,8), 9, "(4+14√2+5√6)/9" }, // (4+5√6+7√8)/9 = (4+5√6+14√2)/9

		{ f(6,5,4,3,2), 1, "16+3√2"         }, // (6+5√4+3√2)/1 = (6+10+3√2)/1 = 16+3√2
		{ f(7,6,5,4,3), 2, "(7+4√3+6√5)/2"  }, // (7+6√5+4√3)/2
		{ f(8,7,6,5,4), 3, "(18+7√6)/3"     }, // (8+7√6+5√4)/3 = (8+7√6+10)/3 = (18+7√6)/3
		{ f(9,8,7,6,5), 4, "(9+6√5+8√7)/4"  }, // (9+8√7+6√5)/4

		{ f(9,8,7,6,5,4,3), 2, "(9+8√7+6√(5+4√3))/2" },
		{ f(0,8,7,6,5,4,3), 2, "4√7+3√(5+4√3)" },
		{ f(0,1,7,6,5,4,3), 2, "(√7+6√(5+4√3))/2" },
		{ f(0,1,1,6,5,4,3), 2, "(1+6√(5+4√3))/2" },
		{ f(0,0,1,6,5,4,3), 2, "3√(5+4√3)" },
		{ f(0,0,1,1,5,4,3), 2, "√(5+4√3)/2" },
		{ f(0,0,1,1,0,4,3), 2, "√(√3)" },
		{ f(0,0,1,1,0,1,3), 2, "√(√3)/2" },
		{ f(0,0,1,1,0,1,1), 2, "1/2" },
		{ f(0,0,1,1,0,0,1), 2, "0" },

	} {
		if q, err := qs.aNew(s.den, s.nums...); err != nil {
			if s.exp != "err" {
				t.Fatalf("reduceQ unexpected overflow for %d %v", s.den, s.nums)
			}
		} else if got := q.String(); got != s.exp {
			t.Fatalf("qs.new got %s exp %s", got, s.exp)
		} else {
			m[got] = q // feed map to be used in add,mul,sqrt,pow2
		}
	}

	// aAdd
	for _, s := range []struct { a, b, exp string } {
		{ "0",   "√2",  "√2"   },
		{ "1",   "1",   "2"    },
		{ "1",   "2",   "3"    },
		{ "3",   "3",   "6"    },
		{ "5/2", "1/2", "3"    },
		{ "1",   "√2",  "1+√2" },
		{ "√2",  "√2",  "2√2"  },
		
		{ "1+√5", "1+√5",     "2+2√5"     },
		{ "1+√5", "(1+√5)/2", "(3+3√5)/2" },
		{ "1+√5", "2√5/3",    "(3+5√5)/3" },

		{ "147√11/2500", "147√11/2500", "147√11/1250" }, // big

		// both bs=0
		{ "√2",    "2√5/3",       "(3√2+2√5)/3"           }, // (3√2)/3 + (2√5)/3 = (3√2+2√5)/3
		{ "√2",    "√2",          "2√2"                   },
		{ "√2",    "147√11/2500", "(2500√2+147√11)/2500"  },
		{ "2√5/3", "147√11/2500", "(5000√5+441√11)/7500"  },
		{ "2√5/3", "2√33/33",     "(22√5+2√33)/33"        },
		{ "√2",    "2√33/33",     "(33√2+2√33)/33"        },
	} {
		if a, ok := m[s.a]; !ok {
			t.Fatalf("qs.AddQ error map has no %s", s.a)
		} else if b, ok := m[s.b]; !ok {
			t.Fatalf("qs.AddQ error map has no %s", s.b)
		} else if r, err := qs.aAdd(a, b); err != nil {
			t.Fatalf("qs.AddQ error for %s %s %v", s.a, s.b, err)
		} else if got := r.String(); got != s.exp {
			t.Fatalf("qs.AddQ got %s exp %s", got, s.exp)
		} else {
			m[got] = r // feed map to be used in multiplications	
		}
	}

	// aMul
	for _, s := range []struct { a, b, exp string } {
		//{ "0",   "√2",  "0"   },
		{ "1",   "1",   "1"   },
		{ "1",   "2",   "2"   },
		{ "3",   "3",   "9"   },
		{ "5/2", "1/2", "5/4" },
		{ "1",   "√2",  "√2"  },
		{ "√2",  "√2",  "2"   },
		
		{ "1+√5", "1+√5",     "6+2√5"      },
		{ "1+√5", "(1+√5)/2", "3+√5"       },
		{ "1+√5", "2√5/3",    "(10+2√5)/3" },
	} {
		a := m[s.a]
		b := m[s.b]
		if r, err := qs.aMul(a, b); err != nil {
			t.Fatalf("aMulPair error for %s %s %v", s.a, s.b, err)
		} else if got := r.String(); got != s.exp {
			t.Fatalf("aMulPair got %s exp %s", got, s.exp)
		} else {
			m[got] = r // add to map valid aMul results
		}
	}

	// aSqrt
	for _, s := range []struct { q, exp string } {
		{ "0",   "0"     },
		{ "1",   "1"     },
		{ "3",   "√3"    },
		{ "5/2", "√10/2" },
		{ "7/5", "√35/5" },
		{ "1/4", "1/2"   },

		{ "√2",    "√(√2)"      },
		{ "2√5/3", "√(6√5)/3"   },
		{ "1+√5",  "√(1+√5)"    },
		{ "6+2√5", "1+√5"       },
		{ "3+√5",  "(√2+√10)/2" },
	} {
		q := m[s.q]
		if r, err := qs.aSqrt(q); err != nil {
			t.Fatalf("aSqrt error for %s %v", s.q, err)
		} else if got := r.String(); got != s.exp {
			t.Fatalf("aSqrt got %s exp %s", got, s.exp)
		} else {
			m[got] = r 
		}
	}

	// aPow2
	for _, s := range []struct { q, exp string } {
		{ "0",     "0" },
		{ "1",     "1" },
		{ "1/2",   "1/4" },

		{ "√3",         "3"     },
		{ "√10/2",      "5/2"   },
		{ "√35/5",      "7/5"   },
		{ "1+√5",       "6+2√5" },
		{ "(√2+√10)/2", "3+√5"  },

		{ "√(√2)",    "√2"    },
		{ "√(6√5)/3", "2√5/3" },

	} {
		q := m[s.q]
		if r, err := qs.aPow2(q); err != nil {
			t.Fatalf("aPow2 error for %s %v", s.q, err)
		} else if got := r.String(); got != s.exp {
			t.Fatalf("aPow2 got %s exp %s", got, s.exp)
		}
	}

}

func TestA32Pow(t *testing.T) {

	qs := NewA32s()

	// pow-sqrt

	p12345, _ := qs.aNew(1,1,2,3,4,5) // 1 + 2√3 + 4√5
	t.Log(p12345)
	a, _ := qs.aPow2(p12345) // 93+4√3+8√(5+10√3)
	t.Log(a)

	p567, _ := qs.aNew(1,5,1,6,1,7) // 5 + √6 + √7
	t.Log(p567)

	b, _ := qs.aPow2(p567) // 38+10√6+2√(35+7√6)
	t.Log(b)


}



